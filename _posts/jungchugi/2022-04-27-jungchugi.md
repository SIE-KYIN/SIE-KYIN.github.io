---
title: 정보처리기사 요약
categories: 
  - certification
excerpt: "정보처리기사의 주요 개념을 요약해봤다:)"
date: 2022-04-27
tags:
- certification
- 정보처리기사
---

# 개요

시나공 정보처리기사 실기 책을 기반으로 한 개념정리

필기에 나온 개념은 실기에도 나올 확률이 높기 때문에 문제 유형을 정리하고

각 장마다 핵심개념을 요약한다.

<br />
<br />

---

# 2022 1회차 필기 문제 유형

---

1. 사용자 인터페이스
2. 애자일 방법론
3. 요구사항 분석 특징
4. 객체지향
5. 통합 테스트(하향식, 상향식)
6. 자료흐름도
7. 모델링
8. UML
9. UI 설계 도구
10. 스크럼
11. UML
12. LOC
13. 클래스 설계 원칙
14. GoF 디자인 패턴
15. 아키텍쳐 설계과정
16. 사용자 인터페이스
17. 디자인 패턴
18. 객체지향 분석기법
19. FEP
20. 객체지향
21. 클린코드
22. 단위 테스트
23. 스택
24. 모듈화 장점
25. 프로젝트 관리
26. 정형 기술 검토
27. 소프트웨어 재공학
28. 프로그래밍 언어선택
29. 소프트웨어 패키징
30. 선형 자료구조
31. Alien Code
32. 소프트웨어 재사용
33. 인터페이스 통신 데이터 포맷
34. NS 차트
35. 스택
36. 정렬알고리즘
37. 화이트 박스 검사기법
38. ISO/IEC 25000
39. 코드 인스펙션
40. 위험분석(Risk Analysis)
41. 데이터베이스 물리적 설계
42. Delete 명령어
43. 정규화 과정
44. E-R 다이어그램
45. DB의 키
46. 관계해석
47. Degree Cardinality
48. 뷰
49. 관계대수
50. 정규화 과정
51. Create Table
52. SQL 특징
53. SQL 실행결과
54. BETWEEN과 같은거
55. 트랜잭션(롤백)
56. DCL 데이터 제어어
57. SQL 실행결과
58. 분산 데이터베이스 시스템
59. SQL 실행결과
60. DB 병행제어
61. IP 주소체계
62. C언어 실행결과
63. OSI 7 LAYERs
64. C언어 연산자
65. IPv6
66. 자바 예외
67. TCP/IP ARP 프로토콜
68. 결합도 응집도
69. 임계구역 접근 제어 상호배제기법
70. 모듈
71. Best Fit
72. C언어 실행결과
73. 자바 실행결과
74. 빌드 도구
75. FIFO 알고리즘
76. C언어 실행결과
77. 파이썬 실행결과
78. C언어 실행결과
79. 파이썬 실행결과
80. 쉘 기능
81. 나선형 모델
82. HACMP(고가용성 솔루션)
83. Switch Jamming
84. 스토리지 시스템 DAS
85. 취약점 관리
86. V 모델
87. 블루투스
88. DoS 공격
89. Honeypot
90. 도커
91. 간트차트
92. CrawlCat
93. Secure 코딩 입력데이터의 보안약점
94. 파일시스템(FAT,NTFS)
95. DES 알고리즘
96. 리눅스 umask
97. 리눅스 로그파일(wtmp)
98. LOC
99. DPI 패킷분석기술
100. 테일러링



<br />
<br />

---

# 1장-요구사항 확인

---

<br />

## 소프트웨어 생명주기

---

* 폭포수 모형
* 프로토타입 모형
* 나선형 모형
* 애자일 모형

<br />

---

## 폭포수 모형

---

각 단계를 확실히 끝내고 다음 단계를 진행


<br />

---

## 프로토타입 모형

---

개발될 소프트웨어의 견본품을 만들어 최종 결과물을 예측

<br />

---

## 나선형 모형

---

여러번의 소프트웨어 개발과정을 거쳐 점진적으로 개발

`계획수립` -> `위험 분석` -> `개발 및 검증` -> `고객 평가`

<br />

---

## 애자일 모형

---

고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발

폭포수와 대조적

<br />

---

### 애자일 핵심가치

---

* 프로세스와 도구보다 개인과의 상호작용 중시
* 문서보다 실행되는 소프트웨어 중시
* 계약 협상보다는 고객과 협업 중시
* 계획을 따르기보다 변화에 반응 중시

<br />

---

## 스크럼

---

팀이 중심이 되어 개발의 효율성을 높이는 기법

<br />

---

## XP(eXtreme Programming)

---

고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발과정의 반복을 통해 생산성을 향상시키는 기법

<br />

---

### XP의 5가지 핵심가치

---

* 의사소통
* 단순성
* 용기
* 존중
* 피드백 

<br />

---

### XP의 12가지 실천방법

---

* pair Programming
* collective ownership
* test-driven development
* whole team
* continuous integration
* refactoring
* small releases
* planning game
* design improvement
* coding standards
* simple design
* system metaphor
* sustainable pace

<br />

---

## 운영체제

---

컴퓨터 자원을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하게 사용할 수 있게 해주는 소프트웨어

<br />

---

### 고려사항

---

* 가용성
* 성능
* 기술지원
* 주변기기
* 구축비용

<br />

---

## DBMS

---

사용자와 DB 사이에서 정보를 생성해주고 DB를 관리해주는 소프트웨어

<br />

---

### 고려사항

---

* 가용성
* 성능
* 기술 지원
* 상호 호환성
* 구축 비용

<br />

---

## 웹 어플리케이션 서버(WAS)

---

동적인 컨텐츠를 처리하기 위해 사용되는 미들웨어

<br />

---

## 요구사항

---

소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 운영되는데 필요한 제약조건

<br />

---

### 요구사항 유형

---

* 기능 요구사항
* 비기능 요구사항
* 사용자 요구사항
* 시스템 요구사항

<br />

---

## 요구사항 개발 프로세스

---

`도출` -> `분석` -> `명세` -> `확인`

<br />

---

## 요구사항 분석

---

자료흐름도

자료사전

<br />

<figure>
	<a href="https://user-images.githubusercontent.com/79088896/165488949-614706a1-17e9-4ed9-a133-ff715938130b.jpeg">
		<img src="https://user-images.githubusercontent.com/79088896/165488949-614706a1-17e9-4ed9-a133-ff715938130b.jpeg" class="w8" />
	</a>
</figure>


<br />

---

## UML

---

시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 객체지향 모델링 언어

<br />

---

## UML 구성 요소

---

* 사물
* 관계
* 다이어그램

<br />

---

## UML 관계

---

사물과 사물 사이의 연관성을 표현

* 연관(Association) : 서로 관련이 있는 관계 (숫자써있으면)
* 집합(Aggregation) : 서로 독립적인 포함관계 (마름모)
* 포함(Composition) : 서로 독립되지 않은 포함관계 (색칠된 마름모)
* 일반화(Generalization) : 일반적이거나 구체적인 관계 (선과 삼각형 화살표 위 아래로)
* 의존(Dependency) : 서로에게 영향을 줄때면 연관을 유지하는 관계 (점선 , 화살표)
* 실체화(Realization) : 할 수 있거나 해야하는 기능 (점선과 삼각형 화살표 위 아래로)

<br />

---

## UML 다이어그램

---

사물과 관계를 도형으로 표현한 것

<br />

---

## 구조적 다이어그램

---

* 클래스 : 클래스 관계
* 객체 : 객체와 객체들의 관계, 럼바우 객체 모델링에 활용
* 컴포넌트 : 컴포넌트 관계 (구현단계에서 사용)
* 배치 : 물리적 요소들의 위치 (구현단계에서 사용)
* 복합체 구조 : 복합 구조
* 패키지 : 모델 요소들을 그룹화한 패키지들의 관계

<br />

---

## 행위 다이어그램

---

* 유스케이스 : 사용자의 요구
* 시퀀스 : 상호작용하는 시스템이나 객체들이 주고받는 메시지
* 커뮤니케이션 : 동작에 참여하는 객체들간의 연관관계
* 상태 : 상태 변화, 럼바우 동적 모델링에서 사용
* 활동 : 처리의 흐름을 순서에 따라 표현
* 상호작용 개요 : 상호작용
* 타이밍 : 객체상태변화와 시간제약을 명시적으로 표현

<br />

---

## 스테레오 타입

---

기본 기능외에 추가적인 기능을 표현하는 것

`<< >>`


<br />

---

## 소프트웨어 재사용

---

이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것

* 합성 중심 : 블록을 만들어서 끼워맞추는 것
* 생성 중심 : 명세를 구체화하여 만드는 것

<br />

---

## 소프트웨어 재공학

---

기존 시스템을 이용하여 나은 시스템을 구축하고, 새로운 기능을 추가해서 성능을 향상시키는 것

<br />

---

## CASE

---

Computer Aided Software Engineering

소프트웨어 개발 과정에서 사용되는 과정을 컴퓨터와 도구를 사용하여 자동화 하는 것

<br />

---

## 하향식 비용 산정 기법

---

과거의 경험을 바탕으로 개발자들이 회의를 통해 비용을 산정하는 기법

<br />

---

## 델파이 기법

---

많은 전문가의 의견을 종합하여 산정하는 기법

<br />

---

## 상향식 비용 산정 기법

---

세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 기법

<br />

---

## LOC

---

* 노력 = 기간 X 인원 = LOC / 1인당 월평균 라인 수
* 비용 = 노력 X 1인당 인건비
* 기간 = 노력 / 인원
* 생산성 = LOC / 노력

<br />

---

## 수학적 산정 기법

---

상향식 비용 산정 기법

* COCOMO
* Putnam
* 기능 점수 모형

<br />

---

## COCOMO 모형

---

LOC에 의한 비용 산정기법

<br />

---

## COCOMO 개발 유형

---

* 조직형(organic) : 중.소 규모의 소프트웨어, 5만 라인 이하
* 반분리형(Semi-Detached Mode) : 중간 규모의 소프트웨어, 30만 라인 이하
* 내장형(Embedded Mode) : 대규모의 소프트웨어, 30만 라인 이상

<br />

---

## Putnam 모형

---

소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형

Rayleigh-Norden 곡선의 노력분포도를 기반으로 함


<br />

---

## 기능 점수 모형

---

소프트웨어의 기능을 증대시키는 요인별로 기능 점수를 구한 후 비용을 산정하는 기법

<br />

---

## 소프트웨어 개발 표준

---

소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준

* ISO/IEC 12207
* CMMI
* SPICE

<br />

---

## ISO/IEC 12207

---

ISO에서 만든 표준 소프트웨어 생명 주기 프로세스

<br />

---

## CMMI

---

소프트웨어 개발 조직의 업무능력 및 성숙도를 평가하는 모델

`초기` -> `관리` -> `정의` -> `정량적 관리` -> `최적화`


<br />

---

## SPICE

---

소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준

`불완전` -> `수행` -> `관리` -> `확립` -> `예측` -> `최적화`


<br />

---

## 소프트웨어 개발 프레임워크

---

소프트웨어 개발에 공통적으로 사용되는 구성요소와 아키텍쳐를 일반화하여 제공해주는 반제품형태의 소프트웨어


<br />

---

### 소프트웨어 개발 프레임워크 특징

---

* 모듈화 
* 재사용성 
* 확장성
* 제어의 역흐름

<br />
<br />

---

# 2장-데이터 입출력 구현

---

<br />

## 데이터베이스

---

공동으로 사용될 데이터를 중복을 배제하여 통합하고 저장장치에 저장하여 사용할 수 있도록하는 운영 데이터

<br />

---

## DBMS

---

사용자의 요구에 따라 정보를 생성해주고, DB를 관리해주는 소프트웨어


<br />

---

## DBMS 필수기능

---

* 정의(definition)
* 조작(Manipulation)
* 제어(Control)


<br />

---

## 스키마

---

데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것


<br />

---

## 스키마 종류

---

* 외부 스키마 : 개인의 입장에서의 논리적 구조
* 개념 스키마 : DB의 전체적인 논리적 구조
* 내부 스키마 : 물리적 저장장치 입장에서 본 DB구조


<br />

---

## 데이터 베이스 설계 순서

---

`요구 조건 분석` -> `개념적 설계` -> `논리적 설계` -> `물리적 설계` -> `구현`


<br />

---

### 요구 조건 분석

---

DB를 필요한 용도를 파악하는 것


<br />

---

### 개념적 설계

---

정보 모델링

현실세계에 대한 인식을 추상적 개념으로 표현하는 과정


<br />

---

### 논리적 설계

---

데이터 모델링

현실 세계에서 발생하는 자료를 DBMS가 지원하는 논리적 자료구조로 변환시키는 과정


<br />

---

### 물리적 설계

---

데이터 구조화

논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환하는 과정


<br />

---

### 구현

---

논리적 설계와 물리적 설계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정


<br />

---

## 데이터 모델

---

현실세계의 정보들을 체계적으로 표현한 개념적 모형


<br />

---

### 데이터 모델에 표시할 요소

---

* 구조
* 연산
* 제약 조건


<br />

---

## E-R 다이어그램

---

* 사각형 : 개체 타입
* 마름모 : 관계 타입
* 타원 : 속성
* 이중 타원 : 다중값 속성
* 밑줄 타원 : 기본키 속성
* 복수 타원 : 복합 속성
* 관계 : 개체간 관계
* 선, 링크 : 개체 타빙과 속성을 연결


<br />

---

## 관계형 데이터베이스

---

테이블을 이용해서 데이터 상호관계를 정의하는 데이터 베이스


<br />

---

### 관계형 데이터베이스 구조

---

* 튜플 : 릴레이션을 구성하는 각각의 행 cardinality
* 속성 : 데이터베이스를 구성하는 가장 작은 논리적 단위(열) degree, 차수
* 도메인 : 하나의 속성이 가지는 값들의 집합

<br />

---

## 관계형 데이터베이스의 키

---

* 주키(primary key) : 후보키 중에서 특별히 선정된 키
* 후보키(candidate key) : 속성들중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합(유일성 최소성 만족)
* 대체키(alternate key) : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키
* 슈퍼키(super key) : 속성들의 집합으로 구성된 키
* 외래키(foreign key) : 다른 릴레이션의 기본키를 참조하는 속성

<br />

---

## 관계형 데이터베이스의 무결성

---

* 개체무결성 : 기본 테이블의 기본키를 구성하는 어떤 속성도 NULL값이나 중복값을 가질 수 없다는 규정
* 참조무결성 : 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야함

<br />

---

## 관계대수

---

원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는 가를 기술하는 절차적인 언어

<br />

---

### 순수 관계연산자

---

* select : 튜플추출 , σ(시그마)
* project : 속성추출 , ㅠ(파이)
* Join : 릴레이션 두개 합침 , ㅣ><ㅣ
* division : 나머지 , %

<br />

---

## 이상(anomaly)

---

테이블에서 데이터의 중복이 발생하고 이 중복으로 릴레이션 조작 시 문제가 발생하는 현상

<br />

---

### 이상 종류

---

* 삽입 이상
* 삭제 이상
* 갱신 이상

<br />

---

## 정규화

---

중복을 제거하여 테이블을 무손실 분해하는 과정

<br />

---

### 정규화 과정

---

<br />

<figure>
	<a href="https://user-images.githubusercontent.com/79088896/165542412-b5ded3d1-5901-462b-816f-9752c537ee85.jpeg">
		<img src="https://user-images.githubusercontent.com/79088896/165542412-b5ded3d1-5901-462b-816f-9752c537ee85.jpeg" class="w8" />
	</a>
</figure>

<br />

---

## 반정규화

---

정규화된 데이터 모델을 의도적으로 통합 중복하여 정규화 원칙을 위배하는 행위

<br />

---

## 시스템 카탈로그

---

다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스

<br />

---

## 트랜잭션

---

논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산

<br />

---

### 트랜잭션의 특성

---

* 원자성(Atomicity) : 커밋되던지 롤백되던지
* 일관성(Consistency) : 실행을 완료하면 일관성있는 상태로 변환
* 독립성(Isolation) : 동시에 트랜잭션이 실행되면 서로 끼어들 수 없음
* 지속성(Durability) : 시스템이 고장나도 영구적으로 반영되어야 함

<br />

---

## 인덱스

---

데이터 레코드를 빠르게 접근하기 위해 키밸류 쌍으로 구성되는 데이터 구조

<br />

---

## 뷰

---

하나 이상의 기본 테이블로부터 유도된 가상 테이블

<br />

---

## 클러스터

---

동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법

<br />

---

## 파티션

---

대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것

<br />

---

### 파티션 종류

---

* 범위분할 : 지정한 열의 값을 기준으로 분할
* 해시분할 : 해시함수를 적용한 결과 값에 따라 분할
* 조합분할 : 범위 + 해시 분할

<br />

---

## 데이터 베이스 접근통제

---

* 임의 접근통제(DAC) : 사용자의 신원에 따라 접근권한 부여
* 강제 접근통제(MAC) : 주체와 객체의 등급을 비교하여 접근권한 부여
* 역할기반 접근통제(RBAC) : 사용자의 역할에 따라 접근권한 부여

<br />
<br />

---

# 3장-통합구현

---

<br />


## XML

---

특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어



<br />
<br />

---

# 4장 - 서버 프로그램 구현

---

<br />


## 소프트웨어 아키텍쳐

---

소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조

<br />

---

### 소프트웨어 아키텍쳐 설계의 기본원리

---

* 모듈화 : 시스템의 기능들을 모듈단위로 나누는 것
* 추상화 : 전체적이고 포괄적인 개념을 설계한 후 구체화시켜 나가는 것
* 단계적 분해 : 상위의 중요개념으로부터 하위의 개념으로 구체화시키는 분할 기법
* 정보 은닉 : 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

<br />

---

## 객체지향

---

요소들을 객체로 만든후 객체들을 조립해서 소프트웨어를 개발하는 기법

<br />

---

### 클래스

---

공통된 속성과 연산을 갖는 객체의 집합

<br />

---

### 메시지

---

객체들간의 상호작용에 사용되는 수단

<br />

---

### 캡슐화(Encapsulation)

---

인터페이스를 제외한 세부 내용을 은닉하는 것

<br />

---

### 상속(Inheritance)

---

상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

<br />

---

### 다형성(Polymorphism)

---

하나의 메시지에 대해 각각의 객체가 고유한 방법으로 응답할 수 있는 능력

<br />

---

## 객체지향 분석

---

사용자의 요구사항과 관련된 객체, 속성, 연산, 관계등을 정의하여 모델링하는 작업

<br />

---

## 럼바우 분석기법

---

모든 소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링하는 기법

<br />

---

## 럼바우 분석활동

---

* 객체 모델링 : 객체 다이어그램으로 표시
* 동적 모델링 : 상태 다이어그램으로 표시
* 기능 모델링 : 자료 흐름도로 표시

<br />

---

## Coad와 Yourdon 기법

---

E-R 다이어그램을 사용하여 모델링

<br />

---

## 모듈

---

모듈화를 통해 분리된 시스템의 각 기능

모듈의 독립성은 결합도(Coupling)과 응집도(Cohesion)에 의해 측정

<br />

---

## 결합도(Coupling)

---

모듈간에 상호 의존하는 정도

결합도가 약할수록 좋음 강하면 안좋음

결합도 강함(안좋음)

* 내용 : 다른 모듈의 내용을 직접참조 혹은 수정할 때 결합도
* 공통 : 공통 데이터 영역을 여러모듈이 사용할 때의 결합도
* 외부 : 다른 모듈에서 데이터를 참조할 때의 결합도
* 제어 : 다른 모듈의 논리적인 흐름을 제어하는 결합도
* 스탬프 : 모듈간의 인터페이스로 자료구조가 전달될때의 결합도
* 자료 : 모듈간의 인터페이스가 자료요소로만 구성될 때의 결합도

결합도 약함(좋음)

<br />

---

## 응집도(Cohesion)

---

모듈의 내부요소들이 서로 관련되어 있는 정도

응집도가 강할수록 좋음 약하면 안좋음

응집도 약함(안좋음)

* 우연적 : 각 구성 요소들이 서로 관련없는 요소로만 구성된 응집도
* 논리적 : 유사한 성격을 가지는 요소들로 형성된 응집도
* 시간적 : 특정 시간에 처리되는 기능들을 모은 응집도
* 절차적 : 다수에 관련된 기능을 가질때 기능을 순차적으로 수행하는 응집도
* 통신적 : 동일한 입출력을 사용하는 요소들의 응집도
* 순차적 : 출력데이터를 그 다음 활동의 입력데이터로의 응집도
* 기능적 : 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도

응집도 강함(좋음)

<br />

---

## 단위 모듈

---

한가지 동작을 수행하는 기능을 모듈로 구현한 것

<br />

---

### 단위 모듈의 구현 과정

---

`단위 기능 명세서 작성` -> `입출력 기능 구현` -> `알고리즘 구현`

<br />

---

## IPC

---

Inter-Process Communication

모듈 간 통신 방식을 구현하기 위해 사용되는 프로그래밍 인터페이스 집합

<br />

---

### 대표 메소드

---

* shared MEmory
* Socket
* Semaphores
* Pipes&named Pipes
* Message Queueing

<br />

---

## 디자인 패턴

---

모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식

GOF의 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴으로 구분된다.

<br />

---

## 생성패턴

---

클래스나 객체의 생성과 참조 과정을 정의하는 패턴

* 추상 팩토리(Abstract Factory) : 구체적인 클래스에 의존하지 않고 객체들의 그룹으로 추상적으로 표현함
* 빌더 : 조합하여 객체를 생성
* 팩토리 메서드 : 생성을 서브클래스에서, 캡슐화한 패턴
* 프로토타입 : 원본 객체 복제
* 싱글톤 : 하나의 객체 생성시 동시에 참조 불가능

<br />

---

## 구조패턴

---

클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴

* 어댑터 : 호환성 있게 해주는 패턴
* 브리지 : 구현부에서 추상층을 분리한 패턴
* 컴포지트 : 여러 객체를 다루고자 하는 패턴
* 데코레이터 : 객체 간의 결합을 통해 기능을 확장할 수 있는 패턴
* 퍼싸드(Facade) : 상위에 인터페이스를 구성한 패턴
* 플라이웨이트(Flyweight) : 인스턴스 공유 메모리절약
* 프록시(Proxy) : 객체 사이 연결 인터패이스 패턴


<br />

---

## 행위 패턴

---

클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

* 책임 연쇄(Chain of Responsibility) : 요청을 처리할 수 있는 객체 책임 연쇄
* 커맨드 : 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
* 인터프리터 : 언어에 문법표현을 정의하는 패턴
* 반복자(Iterator) : 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하는 패턴
* 중재자(Mediator) : 객체의 상호작용을 캡슐화
* 메멘토(Memento) : 특정 시점의 상태로 돌릴수 있는 패턴
* 옵서버(Observer) : 상태가 변화하면 상속된 객체에 변화된 상태를 전달하는 패턴
* 상태(State) : 동일한 동작을 다르게 처리해야할 때 사용하는 패턴
* 전략(Strategy) : 동일한 계열의 알고리즘들을 캡슐화하여 교환할 수 있게하는 패턴
* 템플릿 메서드(Template Method) : 상위 클래스에서 골격정의 하위클래스에서 구체화
* 방문자(Visitor) : 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴

<br />
<br />

---

# 5장 - 인터페이스 구현

---

<br />


## 요구사항 검토

---

* 동료검토 : 명세서 작성자가 설명하고 동료들이 검토하는 방법
* 워크스루 : 검토 회의 전에 명세서를 미리 배포하여 사전 검토 후에 검토 회의를 통해 결함을 발견하는 형태
* 인스펙션 : 명세서 작성자를 제외한 다른 전문가들이 검토하는 방법

<br />

---

## 미들웨어

---

운영체제와 응용 프로그램 사이에서 서비스를 제공하는 소프트웨어

<br />

---

## EAI

---

Enterprise Application Integration

기업 내 각종 어플리케이션 및 플랫폼 간의 상호 연동이 가능하게 해주는 솔루션

* Point-to-Point : 1대1로 연결
* Hub & Spoke : 중앙 집중형 방식
* Message Bus(ESB) : 어플리케이션 사이에 미들웨어
* Hybrid : Hub&Spoke + Message Bus

<br />

---

## 웹서비스

---

네트워크 정보를 표준화된 서비스 형태롤 만들어 공유하는 기술

* SOAP : 네트워크 상에서 HTTP/HTTPS, SMTP등을 이용하여 XML을 교환하기 위한 통신 규약
* WSDL : 웹 서비스나 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어
* UDDI : WSDL을 등록하여 서비스와 서비스 제공자를 검색하고 접근하는데 사용

<br />

---

## WSDL

---
